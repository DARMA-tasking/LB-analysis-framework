To further elucidate the theoretical tradeoff between utilizing more iterations
($i$) or gossiping rounds ($k$), we build a performance model for the load
balancing algorithm to model the computational complexity.

The implementation of the \textsf{Grapevine} algorithm relies on having
efficient termination detection, an extensively well-researched distributed
computing problem. A distributed computation is globally terminated if every
process is locally terminated and there is no message in transit between any
processes. Termination detection is an important distributed problem,
on which many non-bulk-synchronous algorithms rely in order to
correctly sequence operations across complex dynamic communication
patterns.
In \textsf{Grapevine}, it is used to determine when gossiping is
finished and when all load transfers have occurred.

Chandy and Misra~\ref{chandy1986processes} prove the lower and upper bounds on
the control message complexity $T_m$ for any termination detection algorithm,
where $M$ is the total number of messages in an underlying computation and $P$
is the number of processors.
\[
T_m = O(M) = \Omega(P)
\]

Intuitively, the worst-case bound occurs when for every computation message, the
termination detection algorithm is activated. The ``dynamic'' Dijkstra-Scholten
termination algorithm~\ref{dijkstra1980termination} for diffusing computations
utilizes an engagement tree to obtain this bound tightly but never performs
better---even in ``best'' case situations--- than $\Theta(M)$. For distributed
applications in less tightly coupled applications or cases with partial
processor engagement in the computation, this algorithm tends to perform well in
practice. Thus, even the best case time complexity $T_c$ for the
Dijkstra-Scholten algorithms is very costly (and is notably not scalable with
respect to $P$):
\[
T_c = \Omega(P)
\]

In contrast, in tightly-coupled cases when all processors are engaged in the
computation, as in the \textsf{Grapevine} algorithm, $O(M)$ is overly costly to
assume in practice. Thus, the 4-counter, wave-based termination algorithm is
often applied in these contexts that reaches a message complexity lower bound of
$2\cdot P$ in the best case scenario, but costs $O(M\cdot P)$ in the worst
case. However, without arbitrary delays in the computation across all the
processors, a small factor on top of $2\cdot P$ is a highly probable outcome
when utilizing termination to sequence phases in \textsf{Grapevine}. With the
message complexity, we can also bound the time complexity for the 4-counter
termination detection algorithm:
\[
T_c = O(M\cdot log(P)) = \Omega(2\cdot log(P))
\]

With $T_c$ in place, we bound the time complexity of the \textsf{Grapevine}
algorithm, for a single iteration, denoted as $G_c$:
\[
G_c = (O(f\cdot k) + T_c) + (B + T_c)
\]

Todo: finish this section by expanding out $B$


% @article{chandy1986processes,
%   title={How processes learn},
%   author={Chandy, K Mani and Misra, Jayadev},
%   journal={Distributed computing},
%   volume={1},
%   number={1},
%   pages={40--52},
%   year={1986},
%   publisher={Springer}
% }

% @article{dijkstra1980termination,
%   title={Termination detection for diffusing computations},
%   author={Dijkstra, Edsger W and Scholten, Carel S},
%   journal={Information Processing Letters},
%   volume={11},
%   number={1},
%   pages={1--4},
%   year={1980},
%   publisher={Elsevier}
% }