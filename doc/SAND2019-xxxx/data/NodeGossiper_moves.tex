Figure~\ref{NodeGossiper-n8-lstats-i5-k4-f4-t1_0.0-vom} supports
the intuition in that we observe that, as one would expect by looking at
the original object/processor distribution in
Figure~\ref{vt-example_rank_loads}, the most heavily loaded processor
($0$) is the one that offloads the most objects to other ranks; in
fact, every other processor shall receive at least one object from
processor~$0$, with processor $2$ (which was minimally loaded to begin
with) will receive the most.
On the other hand, we observe that marginal load adjustments occur
between the $5$ last ranks ($3$--$7$) which in
Figure~\ref{vt-example_rank_loads} form a cluster of similarly-loaded
processors.

What is less intuitive is that the two processors which were
essentially devoid of significant load initially ($1$ and $2$) are
nonetheless prescribed to ship some of their respective objects to
other ranks; the most surprising being maybe that both processors are
even asked offload several of their respective objects onto the most
heavily loaded of their peers ($0$). 
Upon closer inspection, we see that this apparent paradox is easily
explained by the positive skew in the object times distribution
(cf. Table~\ref{t:vt-example}) which indicates that there are
relatively more object with small than with large times, with a few
outliers in the latter category pulling the mean to the right.
In other words, our variant of the algorithm not only performs gross
load adjustments, but also keeps moving small pieces of work until the
distribution is near-optimally distributed.